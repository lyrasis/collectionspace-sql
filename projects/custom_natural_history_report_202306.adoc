= Custom report on natural history objects

**Draft/unfinished**

Requires https://github.com/lyrasis/collectionspace-sql/blob/main/functions.adoc#deurn[deurn function] to be run prior to running the query.

== Interesting requirements

=== Taxa used in Object description information > Biological information > Determination history > Taxonomic identification > Scientific name field, with additional info from linked Taxon authority

The Taxonomic identification field group is repeatable.

Client wanted Scientific name (populated from Taxon authority), Kind, and Note field values in report.

For each Scientific name, they also wanted the Rank (single value) and Common name (multivalued) values. These are stored in the Taxon authority records.

The query combines Scientific name/taxon term and rank/common name for that term into a formatted value in "determination_taxon" field.

If any taxonomic identification data was recorded at all, each empty value is replaced with "." so that values can be grouped properly across columns.

https://github.com/lyrasis/collectionspace-sql/blob/main/projects/custom_natural_history_report_202306_taxon.csv[Sample output of just the described columns]. The `note` column describes the underlying data that results in the report column values, and is not itself generated by the query.

=== Aggregation of related Condition Check data into a single column

Client specified that the following fields from Condition Check procedures related to each object be included in the report:

* Condition Check section: Reference number
* Condition Check section: Note
* Object Condition Information section: Hazard Description
* Object Condition Information section: Hazard Note
* Object Condition Information section: Condition Description
* Object Condition Information section: Condition Note

This is tricky because:

* 0, 1, or more Condition Check procedures can be attached to any object
* Hazard description and Hazard note are in a repeatable field group in the Condition Check procedure
* Condition description and Condition note are in a repeatable field group in the Condition Check procedure

The query aggregates/summarizes all data from attached condition checks into the `condition_check_data` column. For an object with two related condition checks, the value in this column looks like:

....
CC2020.10
Too friable/delicate/scientifically significant for interactive museum display. Recommend return to storage location.
CONDITION INFO: notexhibitablestable.

CC2020.16
Specimen is friable, broken, or is otherwise not in exhibitable shape.
HAZARD INFO: arsenic (Low hazard).
CONDITION INFO: notexhibitablestable.
....

[source,sql]
----
-- Non-soft-deleted objects with specified responsibledepartment
with nhobjs as (
  select distinct on (obj.id) obj.id, hier.name as objectcsid,
  obj.objectnumber, obj.numberofobjects, obj.collection,
  obj.fieldcollectionplace, obj.fieldcollectionnote,
  obj.objecthistorynote, obj.sex, obj.phase,
  deurn(obj.computedcurrentlocation) as computedcurrentlocation
  from collectionobjects_common obj
  inner join misc on misc.id = obj.id and misc.lifecyclestate != 'deleted'
  inner join hierarchy hier on obj.id = hier.id
  inner join collectionobjects_common_responsibledepartments depts
  on depts.id = obj.id and depts.item = 'natural-history'
  order by obj.id asc
),
-- ids of nhobjs with an inventorystatus value `deaccessioned`
deaccessioned as (
  select invstat.id
  from collectionobjects_common_inventorystatuslist invstat
  where invstat.item like '%''deaccessioned'''
  and exists (
    select 1 from nhobjs where nhobjs.id = invstat.id
  )
),
-- Non-deaccessioned natural history objects -- the base objects for our report
objs as (
  select nhobjs.*
  from nhobjs
  where not exists (
    select 1 from deaccessioned where deaccessioned.id = nhobjs.id
  )
),
-- Rows from hierarchy table needed to link objs to repeatable field group tables
children as (
  select hier.id,
  hier.parentid,
  hier.pos,
  hier.name,
  hier.primarytype
  from hierarchy hier
  inner join objs on objs.id = hier.parentid
  where hier.primarytype in ('annotationGroup', 'localityGroup', 'objectNameGroup',
                 'otherNumber', 'taxonomicIdentGroup')
	or (
		hier.primarytype = 'structuredDateGroup'
		and hier.name = 'collectionobjects_common:fieldCollectionDateGroup'
	)
),
nums as (
	select children.parentid as id,
	string_agg(
	  concat_ws(' ',
	    nums.numbervalue,
	    case when nums.numbertype is null then null
	      else format('(%s)', nums.numbertype)
	    end
	  ),
	  ' | ' order by children.pos
	) as othernumber
	from othernumber nums
	inner join children on children.id = nums.id
	where not (nums.numbertype is null and nums.numbervalue is null)
	group by children.parentid
),
-- responsibledeparment values for objs, concatenated with '|'
respdepts as (
  select respdept.id, string_agg(respdept.item, '|' order by respdept.pos) as responsibledepartment
  from collectionobjects_common_responsibledepartments respdept
  where exists (
    select 1 from objs where respdept.id = objs.id
  )
  group by respdept.id
),
-- One row per inventorystatus value for objs, sorted by position
invstats as (
  select invstat.id, string_agg(deurn(invstat.item), '|' order by invstat.pos) as status
  from collectionobjects_common_inventorystatuslist invstat
  where exists (
    select 1 from objs where objs.id = invstat.id
  )
  group by invstat.id
),
-- briefdescription values
briefdesc as (
	select bd.id,
	string_agg(bd.item, E'\n\n' order by bd.pos) as briefdescription
	from collectionobjects_common_briefdescriptions bd
	where bd.item is not null
	and exists (select 1 from objs where objs.id = bd. id)
	group by bd.id
),
-- One row per obj, object name group note values, concatenated
objnames as (
  select children.parentid as id,
    string_agg(deurn(ong.objectname), '|' order by children.pos) as objectname
  from objectnamegroup ong
  inner join children on children.id = ong.id
  where ong.objectname is not null
  group by children.parentid
),
-- One row per obj, annotation group note values, concatenated
annotationnotes as (
  select children.parentid as id,
    string_agg(ann.annotationnote, '|' order by children.pos) as annotationnote
  from annotationgroup ann
  inner join children on children.id = ann.id
  where ann.annotationnote is not null
  group by children.parentid
),
colldates as (
  select children.parentid as id, string_agg(sd.datedisplaydate, '|') as fieldcollectiondate
  from children
  inner join structureddategroup sd on children.id = sd.id
  where children.name = 'collectionobjects_common:fieldCollectionDateGroup'
  group by children.parentid
),
-- One row per obj, field collectors concatenated with "|"
collectors as (
	select coll.id, string_agg(deurn(coll.item), '|' order by coll.pos) as collector
	from collectionobjects_common_fieldcollectors coll
	where coll.item is not null
	and exists (select 1 from objs where objs.id = coll. id)
	group by coll.id
),
-- One row per obj, form values concatenated with "|"
forms as (
	select frm.id, string_agg(deurn(frm.item), '|' order by frm.pos) as form
	from collectionobjects_common_forms frm
	where frm.item is not null
	and exists (select 1 from objs where objs.id = frm. id)
	group by frm.id
),
-- One row per taxonomic identification group populated for objs
taxids as (
  select children.parentid as id,
  grp.taxon as taxonrefname,
  deurn(grp.identkind) as kind,
  grp.notes
  from taxonomicidentgroup grp
  inner join children on children.id = grp.id
  order by children.parentid, children.pos
),
-- Unique taxon refnames recorded in taxonomic identification scientific name fields for objs
--   For each, adds deurned taxon name and taxon rank (a non-repeatable field)
--   Note that this does not pull in rank for non-preferred forms of Taxon terms used in object records.
taxa as (
  select distinct(tax.taxonrefname),
  tc.id,
  deurn(tax.taxonrefname) as taxon,
  tc.taxonrank
  from taxids tax
  left join taxon_common tc on tc.refname = tax.taxonrefname
  where tax.taxonrefname is not null
),
-- Hierarchy table rows needed to link taxa to commonnamegroup table
taxachildren as (
  select hier.id,
  hier.parentid,
  hier.pos,
  hier.name,
  hier.primarytype
  from hierarchy hier
  inner join taxa on taxa.id = hier.parentid
  where hier.primarytype = 'commonNameGroup'
),
-- One row per taxon, with commonname values concatenated with " | "
commonnames as (
  select taxachildren.parentid as id,
	string_agg(cn.commonname, ' | ' order by taxachildren.pos) as commonname
  from commonnamegroup cn
  inner join taxachildren on taxachildren.id = cn.id
  where cn.commonname is not null
  group by taxachildren.parentid
),
-- One row per taxon (taxa subquery)
--  If there is a rank value for the taxon, prepend "rank: " to the value
--  If there is a concatenated commonnames value for the for the taxon, prepend "common name(s): " to the value
taxadata as (
  select taxa.taxonrefname,
  taxa.taxon,
  case when taxa.taxonrank is null then null
    else format('rank: %s', taxa.taxonrank)
  end as taxonrank,
  case when cn.commonname is null then null
    else format('common name(s): %s', cn.commonname)
  end as commonname
  from taxa
  left join commonnames cn on cn.id = taxa.id
),
-- The previous subquery, but we have concatenated in `details` field any non-null rank and common name values with "; "
taxadatacomb as (
  select tx.taxonrefname,
  tx.taxon,
  concat_ws('; ', tx.taxonrank, tx.commonname) as details
  from taxadata tx
),
-- The previous subquery, but now we have, in `taxonwithdetail` field, created the formatted taxon-with-details string
taxadatacombformat as (
  select tx.taxonrefname,
  case when tx.details = '' then tx.taxon
    else format('%s (%s)', tx.taxon, tx.details)
  end as taxonwithdetail
  from taxadatacomb tx
),
-- For each taxonomic id group populated in objs, merge in the taxon-with-details string, and replace
--   null kind and notes values with NULLVALUE to retain proper position of each value when repeated
--   (when the values are concatenated in the following steps)
taxiddata as (
  select tid.id,
  tid.taxonrefname,
  td.taxonwithdetail as taxon,
  coalesce(tid.kind, '.') as kind,
  coalesce(tid.notes, '.') as notes
  from taxids tid
  left join taxadatacombformat td on td.taxonrefname = tid.taxonrefname
),
-- One row per objs id, with taxon-with-details data concatenated with ' ||| '
taxonforobj as (
  select td.id, string_agg(td.taxon, ' ||| ') as taxon
  from taxiddata td
  group by td.id
),
-- One row per objs id, with kind values concatenated with ' ||| '
taxonkindforobj as (
  select td.id, string_agg(td.kind, ' ||| ') as kind
  from taxiddata td
  group by td.id
),
-- One row per objs id, with notes values concatenated with ' ||| '
taxonnotesforobj as (
  select td.id, string_agg(td.notes, ' ||| ') as notes
  from taxiddata td
    group by td.id
),
locality as (
	select children.parentid as id,
    string_agg(coalesce(loc.fieldlocverbatim, '.'), ' | ' order by children.pos) as fieldlocverbatim,
    string_agg(coalesce(deurn(loc.fieldlocplace), '.'), ' | ' order by children.pos) as fieldlocplace,
    string_agg(coalesce(loc.fieldloccounty, '.'), ' | ' order by children.pos) as fieldloccounty,
    string_agg(coalesce(loc.fieldlocstate, '.'), ' | ' order by children.pos) as fieldlocstate,
    string_agg(coalesce(loc.fieldloccountry, '.'), ' | ' order by children.pos) as fieldloccountry,
    string_agg(coalesce(loc.localitynote, '.'), ' | ' order by children.pos) as localitynote
	from localitygroup loc
	inner join children on children.id = loc.id
	where not (
		loc.fieldlocverbatim is null and
		loc.fieldlocplace is null and
		loc.fieldloccounty is null and
		loc.fieldlocstate is null and
		loc.fieldloccountry is null and
		loc.localitynote is null
	)
 	group by children.parentid
),
relacq as (
  select objs.id as objid,
	acq.id as acqid,
	acq.acquisitionreferencenumber,
	acq.acquisitionmethod
  from relations_common rel
  inner join objs on objs.objectcsid = rel.subjectcsid
  inner join hierarchy hier on rel.objectcsid = hier.name
  inner join acquisitions_common acq on acq.id = hier.id
  where rel.objectdocumenttype = 'Acquisition'
),
acqsrcs as (
	select src.id as acqid,
	format('Source(s): %s', string_agg(distinct deurn(src.item), ' | ')) as acqsrc
	from acquisitions_common_acquisitionsources src
	inner join relacq on relacq.acqid = src.id
	where src.item is not null
	group by src.id
),
acqinfo as (
	select relacq.objid, relacq.acqid,
	string_agg(
	  concat_ws(E'\n',
	    concat_ws(' - ',
	      relacq.acquisitionreferencenumber,
	      dates.datedisplaydate,
	      relacq.acquisitionmethod),
	    acqsrcs.acqsrc
	  ), E'\n\n'
	) as info
	from relacq
	inner join acqsrcs on acqsrcs.acqid = relacq.acqid
	inner join hierarchy hier on hier.parentid = relacq.acqid
	  and hier.name = 'acquisitions_common:accessionDateGroup'
	inner join structureddategroup dates on hier.id = dates.id
	group by relacq.objid, relacq.acqid
),
-- One row per relationship of a condition check procedure to objs
--   Assumes relationships between object and deleted procedure will have
--   been deleted
relcc as (
  select objs.id as objid,
  cc.id as ccid,
  cc.conditioncheckrefnumber,
  regexp_replace(cc.conditionchecknote, '\n*$', '') as conditionchecknote
  from relations_common rel
  inner join objs on objs.objectcsid = rel.subjectcsid
  inner join hierarchy hier on rel.objectcsid = hier.name
  inner join conditionchecks_common cc on cc.id = hier.id
  where rel.objectdocumenttype = 'Conditioncheck'
),
-- Unique condition check records related to objs, for further processing/
--   data aggregation
uniqccs as (
  select distinct(ccid), conditioncheckrefnumber, conditionchecknote
  from relcc
),
-- Hierarchy table rows needed to link condition checks to repeatable field group tables
ccchildren as (
  select hier.id,
  hier.parentid,
  hier.pos,
  hier.name,
  hier.primarytype
  from hierarchy hier
  inner join uniqccs on uniqccs.ccid = hier.parentid
  where hier.primarytype in ('hazardGroup', 'conditionCheckGroup')
),
-- Individual hazard group rows, with description and note formatted and combined
hazgrps as (
  select ccchildren.parentid as id,
  concat_ws(' ',
        haz.hazard,
    case when haz.hazardnote is null then null
     else format('(%s)', haz.hazardnote)
    end
    ) as hazardinfo
  from hazardgroup haz
  inner join ccchildren on ccchildren.id = haz.id
  where not (haz.hazard is null and haz.hazardnote is null)
  order by ccchildren.parentid, ccchildren.pos
),
-- One row per condition check; concatenates multiple hazard group values and
--   prepends "HAZARD INFO: " prefix
hazards as (
  select haz.id,
  format(
      'HAZARD INFO: %s.',
    string_agg(haz.hazardinfo, '; ')
  )  as hazard
  from hazgrps haz
  group by haz.id
),
-- Individual condition group rows, with description and note formatted and combined
condgrps as (
  select ccchildren.parentid as id,
  concat_ws(' ',
        cond.condition,
    case when cond.conditionnote is null then null
     else format('(%s)', cond.conditionnote)
    end
    ) as conditioninfo
  from conditioncheckgroup cond
  inner join ccchildren on ccchildren.id = cond.id
  where not (cond.condition is null and cond.conditionnote is null)
  order by ccchildren.parentid, ccchildren.pos
),
-- One row per condition check; concatenates multiple condition group values and
--   prepends "CONDITION INFO: " prefix
conditions as (
  select cond.id,
  format(
      'CONDITION INFO: %s.',
    string_agg(cond.conditioninfo, '; ')
  )  as condition
  from condgrps cond
  group by cond.id
),
-- One row per condition check; combines hazard and condition data
ccgrpdata as (
  select ucc.ccid,
  concat_ws(E'\n',
        hazards.hazard,
            conditions.condition
        ) as grpdata
  from uniqccs ucc
  left join hazards on hazards.id = ucc.ccid
  left join conditions on conditions.id = ucc.ccid
  where not (hazards.hazard is null and conditions.condition is null)
),
-- One row per condition check; formats all data for each condition check
--   into a string
ccfull as (
  select ucc.ccid,
  concat_ws(E'\n',
       ucc.conditioncheckrefnumber,
       ucc.conditionchecknote,
       grp.grpdata) as ccdata
  from uniqccs ucc
  left join ccgrpdata grp on grp.ccid = ucc.ccid
),
-- One row per objs; concatenates strings from all related condition checks into
--   a string
ccconcat as (
  select relcc.objid,
  string_agg(ccfull.ccdata, E'\n\n') as ccdata
  from relcc
  inner join ccfull on ccfull.ccid = relcc.ccid
  group by relcc.objid
)

select
  objs.objectnumber,
  objs.numberofobjects,
  nums.othernumber,
  respdepts.responsibledepartment,
  objs.collection,
  deurn(ohcobj.descriptionlevel) as descriptionlevel,
  bd.briefdescription,
  objs.computedcurrentlocation,
  statuses.status,
  objnames.objectname,
  annotationnotes.annotationnote,
  colldates.fieldcollectiondate,
  deurn(objs.fieldcollectionplace) as fieldcollectionplace,
  anthro.fieldlocverbatim,
  coll.collector as fieldcollector,
  objs.fieldcollectionnote,
  forms.form,
  objs.sex,
  objs.phase,
  deurn(ohcobj.majortaxon) as majortaxon,
  taxon.taxon as determination_taxon,
  taxonkind.kind as determination_kind,
  taxonnotes.notes as determination_notes,
  objs.objecthistorynote,
  loc.fieldlocverbatim,
  loc.fieldlocplace,
  loc.fieldloccounty,
  loc.fieldlocstate,
  loc.fieldloccountry,
  loc.localitynote,
  acqinfo.info as acquisition_data,
  ccconcat.ccdata as condition_check_data
from objs
left join nums on nums.id = objs.id
left join respdepts on respdepts.id = objs.id
left join invstats statuses on statuses.id = objs.id
left join collectionobjects_ohc ohcobj on ohcobj.id = objs.id
left join briefdesc bd on bd.id = objs.id
left join collectionobjects_anthro anthro on anthro.id = objs.id
left join objnames on objnames.id = objs.id
left join annotationnotes on annotationnotes.id = objs.id
left join colldates on colldates.id = objs.id
left join collectors coll on coll.id = objs.id
left join forms on forms.id = objs.id
left join taxonforobj taxon on taxon.id = objs.id
left join taxonkindforobj taxonkind on taxonkind.id = objs.id
left join taxonnotesforobj taxonnotes on taxonnotes.id = objs.id
left join locality loc on loc.id = objs.id
left join acqinfo on acqinfo.objid = objs.id
left join ccconcat on ccconcat.objid = objs.id
----
