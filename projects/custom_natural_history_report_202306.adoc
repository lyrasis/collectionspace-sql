= Custom report on natural history objects

**Draft/unfinished**

Requires https://github.com/lyrasis/collectionspace-sql/blob/main/functions.adoc#deurn[deurn function] to be run prior to running the query.

== Interesting requirements

=== Taxa used in Object description information > Biological information > Determination history > Taxonomic identification > Scientific name field, with additional info from linked Taxon authority

The Taxonomic identification field group is repeatable.

Client wanted Scientific name (populated from Taxon authority), Kind, and Note field values in report.

For each Scientific name, they also wanted the Rank (single value) and Common name (multivalued) values. These are stored in the Taxon authority records.

The query combines Scientific name/taxon term and rank/common name for that term into a formatted value in "determination_taxon" field.

If any taxonomic identification data was recorded at all, each empty value is replaced with "NULLVALUE" so that values can be grouped properly across columns.

https://github.com/lyrasis/collectionspace-sql/blob/main/projects/custom_natural_history_report_202306_taxon.csv[Sample output of just the described columns]. The `note` column describes the underlying data that results in the report column values, and is not itself generated by the query.

=== Aggregation of related Condition Check data into a single column

Client specified that the following fields from Condition Check procedures related to each object be included in the report:

* Condition Check section: Reference number
* Condition Check section: Note
* Object Condition Information section: Hazard Description
* Object Condition Information section: Hazard Note
* Object Condition Information section: Condition Description
* Object Condition Information section: Condition Note

This is tricky because:

* 0, 1, or more Condition Check procedures can be attached to any object
* Hazard description and Hazard note are in a repeatable field group in the Condition Check procedure
* Condition description and Condition note are in a repeatable field group in the Condition Check procedure

The query aggregates/summarizes all data from attached condition checks into the `condition_check_data` column. For an object with two related condition checks, the value in this column looks like:

....
CC2020.10
Too friable/delicate/scientifically significant for interactive museum display. Recommend return to storage location.
CONDITION INFO: notexhibitablestable.

CC2020.16
Specimen is friable, broken, or is otherwise not in exhibitable shape.
HAZARD INFO: arsenic (Low hazard).
CONDITION INFO: notexhibitablestable.
....

[source,sql]
----
-- Non-soft-deleted objects with specified responsibledepartment
with nhobjs as (
  select distinct on (obj.id) obj.id, hier.name as objectcsid,
  obj.objectnumber, obj.numberofobjects, obj.collection,
  obj.fieldcollectionplace, obj.fieldcollectionnote,
  obj.objecthistorynote, obj.sex, obj.phase,
  deurn(obj.computedcurrentlocation) as computedcurrentlocation
  from collectionobjects_common obj
  inner join misc on misc.id = obj.id and misc.lifecyclestate != 'deleted'
  inner join hierarchy hier on obj.id = hier.id
  inner join collectionobjects_common_responsibledepartments depts
  on depts.id = obj.id and depts.item = 'natural-history'
  order by obj.id asc
),
-- ids of nhobjs with an inventorystatus value `deaccessioned`
deaccessioned as (
  select invstat.id
  from collectionobjects_common_inventorystatuslist invstat
  where invstat.item like '%''deaccessioned'''
  and exists (
    select 1 from nhobjs where nhobjs.id = invstat.id
  )
),
-- Non-deaccessioned natural history objects -- the base objects for our report
objs as (
  select nhobjs.*
  from nhobjs
  where not exists (
    select 1 from deaccessioned where deaccessioned.id = nhobjs.id
  )
),
-- Rows from hierarchy table needed to link objs to repeatable field group tables
children as (
  select hier.id,
  hier.parentid,
  hier.pos,
  hier.name,
  hier.primarytype
  from hierarchy hier
  inner join objs on objs.id = hier.parentid
  where hier.primarytype in ('annotationGroup', 'localityGroup', 'objectNameGroup',
                 'otherNumber', 'structuredDateGroup', 'taxonomicIdentGroup')
),
-- One row per responsibledeparment value for objs, sorted by position
respdept as (
  select respdept.id, respdept.item as dept
  from collectionobjects_common_responsibledepartments respdept
  where exists (
    select 1 from objs where respdept.id = objs.id
  )
    order by respdept.pos
),
-- One row per objs id, with responsibledepartment values concatenated with |
respdepts as (
  select respdept.id, string_agg(respdept.dept, '|') as responsibledepartment
  from respdept
  group by respdept.id
),
-- One row per inventorystatus value for objs, sorted by position
invstat as (
  select invstat.id, deurn(invstat.item) as status
  from collectionobjects_common_inventorystatuslist invstat
  where exists (
    select 1 from objs where objs.id = invstat.id
  )
  order by invstat.pos
),
-- One row per objs id, with inventorystatus values concatenated with |
invstatconcat as (
  select invstat.id, string_agg(invstat.status, '|') as status
  from invstat
  group by invstat.id
),
-- One row per annotation group populated for objs
annotations as (
  select children.parentid as id, ann.annotationnote
  from annotationgroup ann
  inner join children on children.id = ann.id
  where ann.annotationnote is not null
  order by children.parentid, children.pos
),
-- One row per objs id, with annotationnote values concatenated with |
annotationnotes as (
  select ann.id, string_agg(ann.annotationnote, '|') as annotationnote
  from annotations ann
  group by ann.id
),
-- One row per taxonomic identification group populated for objs
taxids as (
  select children.parentid as id,
  grp.taxon as taxonrefname,
  deurn(grp.identkind) as kind,
  grp.notes
  from taxonomicidentgroup grp
  inner join children on children.id = grp.id
  order by children.parentid, children.pos
),
-- Unique taxon refnames recorded in taxonomic identification scientific name fields for objs
--   For each, adds deurned taxon name and taxon rank (a non-repeatable field)
--   Note that this does not pull in rank for non-preferred forms of Taxon terms used in object records.
taxa as (
  select distinct(tax.taxonrefname),
  tc.id,
  deurn(tax.taxonrefname) as taxon,
  tc.taxonrank
  from taxids tax
  left join taxon_common tc on tc.refname = tax.taxonrefname
  where tax.taxonrefname is not null
),
-- Hierarchy table rows needed to link taxa to commonnamegroup table
taxachildren as (
  select hier.id,
  hier.parentid,
  hier.pos,
  hier.name,
  hier.primarytype
  from hierarchy hier
  inner join taxa on taxa.id = hier.parentid
  where hier.primarytype = 'commonNameGroup'
),
-- One row per commonnamegroup populated for taxa
commonname as (
  select taxachildren.parentid as id, cn.commonname
  from commonnamegroup cn
  inner join taxachildren on taxachildren.id = cn.id
  where cn.commonname is not null
  order by taxachildren.parentid, taxachildren.pos
),
-- One row per taxon record in which common names are assigned, with names concatenated with " | "
commonnames as (
  select cn.id, string_agg(cn.commonname, ' | ') as commonname
  from commonname cn
  group by cn.id
),
-- One row per taxon (taxa subquery)
--  If there is a rank value for the taxon, prepend "rank: " to the value
--  If there is a concatenated commonnames value for the for the taxon, prepend "common name(s): " to the value
taxadata as (
  select taxa.taxonrefname,
  taxa.taxon,
  case when taxa.taxonrank is null then null
    else format('rank: %s', taxa.taxonrank)
  end as taxonrank,
  case when cn.commonname is null then null
    else format('common name(s): %s', cn.commonname)
  end as commonname
  from taxa
  left join commonnames cn on cn.id = taxa.id
),
-- The previous subquery, but we have concatenated in `details` field any non-null rank and common name values with "; "
taxadatacomb as (
  select tx.taxonrefname,
  tx.taxon,
  concat_ws('; ', tx.taxonrank, tx.commonname) as details
  from taxadata tx
),
-- The previous subquery, but now we have, in `taxonwithdetail` field, created the formatted taxon-with-details string
taxadatacombformat as (
  select tx.taxonrefname,
  case when tx.details = '' then tx.taxon
    else format('%s (%s)', tx.taxon, tx.details)
  end as taxonwithdetail
  from taxadatacomb tx
),
-- For each taxonomic id group populated in objs, merge in the taxon-with-details string, and replace
--   null kind and notes values with NULLVALUE to retain proper position of each value when repeated
--   (when the values are concatenated in the following steps)
taxiddata as (
  select tid.id,
  tid.taxonrefname,
  td.taxonwithdetail as taxon,
  coalesce(tid.kind, 'NULLVALUE') as kind,
  coalesce(tid.notes, 'NULLVALUE') as notes
  from taxids tid
  left join taxadatacombformat td on td.taxonrefname = tid.taxonrefname
),
-- One row per objs id, with taxon-with-details data concatenated with ' ||| '
taxonforobj as (
  select td.id, string_agg(td.taxon, ' ||| ') as taxon
  from taxiddata td
  group by td.id
),
-- One row per objs id, with kind values concatenated with ' ||| '
taxonkindforobj as (
  select td.id, string_agg(td.kind, ' ||| ') as kind
  from taxiddata td
  group by td.id
),
-- One row per objs id, with notes values concatenated with ' ||| '
taxonnotesforobj as (
  select td.id, string_agg(td.notes, ' ||| ') as notes
  from taxiddata td
    group by td.id
),
-- One row per relationship of a condition check procedure to objs
--   Assumes relationships between object and deleted procedure will have
--   been deleted
relcc as (
  select objs.id as objid,
  cc.id as ccid,
  cc.conditioncheckrefnumber,
  regexp_replace(cc.conditionchecknote, '\n*$', '') as conditionchecknote
  from relations_common rel
  inner join objs on objs.objectcsid = rel.subjectcsid
  inner join hierarchy hier on rel.objectcsid = hier.name
  inner join conditionchecks_common cc on cc.id = hier.id
  where rel.objectdocumenttype = 'Conditioncheck'
),
-- Unique condition check records related to objs, for further processing/
--   data aggregation
uniqccs as (
  select distinct(ccid), conditioncheckrefnumber, conditionchecknote
  from relcc
),
-- Hierarchy table rows needed to link condition checks to repeatable field group tables
ccchildren as (
  select hier.id,
  hier.parentid,
  hier.pos,
  hier.name,
  hier.primarytype
  from hierarchy hier
  inner join uniqccs on uniqccs.ccid = hier.parentid
  where hier.primarytype in ('hazardGroup', 'conditionCheckGroup')
),
-- Individual hazard group rows, with description and note formatted and combined
hazgrps as (
  select ccchildren.parentid as id,
  concat_ws(' ',
        haz.hazard,
    case when haz.hazardnote is null then null
     else format('(%s)', haz.hazardnote)
    end
    ) as hazardinfo
  from hazardgroup haz
  inner join ccchildren on ccchildren.id = haz.id
  where not (haz.hazard is null and haz.hazardnote is null)
  order by ccchildren.parentid, ccchildren.pos
),
-- One row per condition check; concatenates multiple hazard group values and
--   prepends "HAZARD INFO: " prefix
hazards as (
  select haz.id,
  format(
      'HAZARD INFO: %s.',
    string_agg(haz.hazardinfo, '; ')
  )  as hazard
  from hazgrps haz
  group by haz.id
),
-- Individual condition group rows, with description and note formatted and combined
condgrps as (
  select ccchildren.parentid as id,
  concat_ws(' ',
        cond.condition,
    case when cond.conditionnote is null then null
     else format('(%s)', cond.conditionnote)
    end
    ) as conditioninfo
  from conditioncheckgroup cond
  inner join ccchildren on ccchildren.id = cond.id
  where not (cond.condition is null and cond.conditionnote is null)
  order by ccchildren.parentid, ccchildren.pos
),
-- One row per condition check; concatenates multiple condition group values and
--   prepends "CONDITION INFO: " prefix
conditions as (
  select cond.id,
  format(
      'CONDITION INFO: %s.',
    string_agg(cond.conditioninfo, '; ')
  )  as condition
  from condgrps cond
  group by cond.id
),
-- One row per condition check; combines hazard and condition data
ccgrpdata as (
  select ucc.ccid,
  concat_ws(E'\n',
        hazards.hazard,
            conditions.condition
        ) as grpdata
  from uniqccs ucc
  left join hazards on hazards.id = ucc.ccid
  left join conditions on conditions.id = ucc.ccid
  where not (hazards.hazard is null and conditions.condition is null)
),
-- One row per condition check; formats all data for each condition check
--   into a string
ccfull as (
  select ucc.ccid,
  concat_ws(E'\n',
       ucc.conditioncheckrefnumber,
       ucc.conditionchecknote,
       grp.grpdata) as ccdata
  from uniqccs ucc
  left join ccgrpdata grp on grp.ccid = ucc.ccid
),
-- One row per objs; concatenates strings from all related condition checks into
--   a string
ccconcat as (
  select relcc.objid,
  string_agg(ccfull.ccdata, E'\n\n') as ccdata
  from relcc
  inner join ccfull on ccfull.ccid = relcc.ccid
  group by relcc.objid
)
select
  objs.id,
  objs.objectnumber,
  objs.numberofobjects,
  respdepts.responsibledepartment,
  objs.collection,
  objs.computedcurrentlocation,
  statuses.status,
  annotationnotes.annotationnote,
  objs.fieldcollectionplace,
  objs.fieldcollectionnote,
  objs.sex,
  objs.phase,
  deurn(ohcobj.majortaxon) as majortaxon,
  taxon.taxon as determination_taxon,
  taxonkind.kind as determination_kind,
  taxonnotes.notes as determination_notes,
  objs.objecthistorynote,
  ccconcat.ccdata as condition_check_data
from objs
left join respdepts on respdepts.id = objs.id
left join invstatconcat statuses on statuses.id = objs.id
left join collectionobjects_ohc ohcobj on ohcobj.id = objs.id
left join annotationnotes on annotationnotes.id = objs.id
left join taxonforobj taxon on taxon.id = objs.id
left join taxonkindforobj taxonkind on taxonkind.id = objs.id
left join taxonnotesforobj taxonnotes on taxonnotes.id = objs.id
left join ccconcat on ccconcat.objid = objs.id

----
